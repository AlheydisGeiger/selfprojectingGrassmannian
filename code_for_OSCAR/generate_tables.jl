#Code to generate the rows of Tables 2-4 in Section 4 of the Article "The self-dual Grassmannian"


using Oscar;
#n = 4, means dim(R), n=6 means dim(S)
#d is the value of the dimension for which we are counting the occurences in the inputfile
function count_dimensions(filename::String,n::Int,d::Int)::Int
    result = Int[]
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing && parse(Int, m.captures[n]) ==d
                push!(result,parse(Int, m.captures[n]))
            end
        end
    end
    return length(result)
end

#if the file was computed using the code in one of the *_onlyR.m magma files, the pattern for regex is different
function count_dimensions_onlyR(filename::String,n::Int,d::Int)::Int
    result = Int[]
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(\w*):(\w*):(\w*):(.*)"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing && parse(Int, m.captures[n]) ==d
                push!(result,parse(Int, m.captures[n]))
            end
        end
    end
    return length(result)
end

#this function generates the rows of the Tables giving the dimensions of R for rank k matroids on n elements as computed in the inputfile
function generate_table_content_dimR(inputfile::String,k::Int,n::Int)
    v = -1:(k*(n-k)-(n-1))
    vstar = vcat([-(n+1)],0:(k*(n-k)-(n-1)))
    d = length(v);
    println("The dimensions of the realization spaces for self-projecting rank $k matroids on $n elements are distributed as follows (without the uniform matroid)")
    return vcat(matrix(QQ,1,d,v),matrix(QQ,1,d,[count_dimensions(inputfile,4,i) for i in vstar]))
end

#this function generates the rows of the Tables giving the dimensions of R for rank k matroids on n elements as computed in the inputfile which was generated using the *_onlyR.m magma code
function generate_table_content_dimR_onlyR(inputfile::String,k::Int,n::Int)
    v = -1:(k*(n-k)-(n-1))
    vstar = vcat([-(n+1)],0:(k*(n-k)-(n-1)))
    d = length(v);
    println("The dimensions of the realization spaces for self-projecting rank $k matroids on $n elements are distributed as follows (without the uniform matroid)")
    return vcat(matrix(QQ,1,d,v),matrix(QQ,1,d,[count_dimensions_onlyR(inputfile,4,i) for i in vstar]))
end

#this function generates the rows of the Tables giving the dimensions of the selfprojecting realization space S for rank k matroids on n elements as computed in the inputfile
function generate_table_content_dimS(inputfile::String,k::Int,n::Int)
    v = -1:(k*(n-k)-(n-1))
    vstar = vcat([-(n+1)],0:(k*(n-k)-(n-1)))
    d = length(v);
    println("The dimensions of the self-projecting realization spaces for self-projecting rank $k matroids on $n elements are distributed as follows (without the uniform matroid)")
    return vcat(matrix(QQ,1,d,v),matrix(QQ,1,d,[count_dimensions(inputfile,6,i) for i in vstar]))
end

#this functions checks for how many matroids for which R and S were computed and printed to the inputfile, satisfy that R = S (true: R = S, false: S is a proper subset of R)
function check_equality(inputfile::String)
    i =0
    j =0
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    open(inputfile, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing &&  m.captures[7] == "true"
                i =i+1
            elseif m !== nothing && m.captures[7] == "false"
                j = j+1
            end
        end
    end
    return  ("true:$i","false:$j")
end


#This function can be used to extract a specific entry from a line in the files generated by magma using the general code
#Note that the Output of this function is a String!
#1 gives the identifier (as used in the oscarDB database collection)
#2 are the bases of the matroid isomorphic to the one stored in the database collection, these bases were the start for the magma computations
#3 is the groebner_basis for the realization space R (of a matroid isomorphic to #2)
#4 is the dimension of R 
#5 is the groebner_basis for the selfprojecting realization space S (of a matroid isomorphic to #2)
#6 is the dimension of S 
#7 states whether R == S 
#8 is a template for a selfprojecting realization as in S
function extract_entry(line::String,n::Int)::String
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    m = match(pattern, line)
    if m !== nothing
        result = m.captures[n]
    else 
        error("Input did not match the pattern")
    end
    return result
end

#This function can be used to extract a specific entry from a line in the files generated by magma using the *_onlyR.m code
#Note that the Output of this function is a String!
#1 gives the identifier (as used in the oscarDB database collection)
#2 are the bases of the matroid isomorphic to the one stored in the database collection, these bases were the start for the magma computations
#3 is the groebner_basis for the realization space R (of a matroid isomorphic to #2)
#4 is the dimension of R 
#5 Nothing
#6 Nothing
#7 Nothing
#8 is a template for a selfprojecting realization as in R
function extract_entry_onlyR(line::String,n::Int)::String
    # Regex: match digits at the start of the line, followed by a colon
    #(id:bases:gb:dim:gb:dim:bool:template)
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(\w*):(\w*):(\w*):(.*)"
    m = match(pattern, line)
    if m !== nothing
        result = m.captures[n]
    else 
        error("Input did not match the pattern")
    end
    return result
end

#This function counts for a given magma outputfile, which contains the computations of both R and S, how many matroids are realizable without a self-projecting realization.
function count_realizable_not_sp_realizable(inputfile::String)
    count = 0
    open(inputfile,"r") do file 
        for line in eachline(file) 
            if (parse(Int,extract_entry(line,4))>=0) && (parse(Int,extract_entry(line,6))<0)
                count = count+1
            end
        end
    end
    return count
end

#This function counts for a given magma outputfile, which contains the computations of both R and S, how many matroids are realizable with d= dim(R), without a self-projecting realization.
function find_all_realizable_not_sp_realizable(inputfile::String,d::Int)
    count = []
    open(inputfile,"r") do file 
        for line in eachline(file) 
            if (parse(Int,extract_entry(line,4))==d) && (parse(Int,extract_entry(line,6))<0)
                push!(count,parse(Int,extract_entry(line,1)))
            end
        end
    end
    return count
end

#This function counts how often the stored boolean is true/false in a given file containing both R and S
function count_booleans(filename::String,d::Bool)::Int
    result = Int[]
    n = 7
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line) 
            if m !== nothing && parse(Bool, m.captures[n]) ==d
                push!(result,parse(Bool, m.captures[n]))
            end
        end
    end
    return length(result)
end



#This function extracts the set of all identifies from a given magma outputfile and returns them as a set
function extract_first_ints(filename::String)::Set{Int}
    result = Set()
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing
                push!(result, parse(Int, m.captures[1]))
            end
        end
    end
    return result
end

#This function returns the set of identifiers not contained in the given magma outputfile. The set of identifies is compared to the set of elements in 1:n where n is given to the function.
function find_not_terminated(filename::String,n::Int)::Set{Int}
    S = Set{Int}(i for i in 1:n)
    t = extract_first_ints(filename)
    return setdiff!(S,t)
end

#This function extracts the set of all identifies from a given magma outputfile and returns them as a vector
function extract_entries_vector(filename::String,n::Int)::Vector{String}
    result = String[]
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing
                push!(result, m.captures[n])
            end
        end
    end
    return result
end

#This function returns the set of all entries in position n from the lines of a given magma outputfile
function extract_entries_set(filename::String,n::Int)::Set{String}
    result = Set()
    # Regex: match digits at the start of the line, followed by a colon
    pattern = r"^(\d+):(.*):(.*):(-?\d*):(.*):(-?\d*):(\w*):(.*)"
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing
                push!(result, m.captures[n])
            end
        end
    end
    return result
end

#this function returns a vector of identifiers 
#The matroids connected to these identifiers satisfy a specific property indicated by the pattern given to the function
function find_matroids_with_properties(filename::String,pattern::Regex)::Vector{Int}
    result = Int[]
    # Regex: match digits at the start of the line, followed by a colon
    open(filename, "r") do file
        for line in eachline(file)
            m = match(pattern, line)
            if m !== nothing
                push!(result, parse(Int, m.captures[1]))
            end
        end
    end
    return result
end

#this function returns the number of matroids satisfying a specific property indicated by the pattern given to the function
function count_pattern_in_file(filename::String, pattern::Regex)
    count = 0
    open(filename, "r") do file
        for line in eachline(file)
            count += count_occurrences(line, pattern)
        end
    end
    return count
end

